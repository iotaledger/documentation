# Design the messaging workflow

**As a channel author, you have many options for designing how you and your subscribers will interact. To create a fluid and natural experience, it is important to think about all the different ways a subscriber might need to interact with your app as well as the types of messages you may need to send. This article walks you through the process of designing a Channels messaging app.**

In a channel, messages can reference the message identifier of any other [message type](../channels/how-channels-works.md#message-types).

These references allow the author and subscribers to make sure that the information in their [state](../channels/how-channels-works.md#author-and-subscriber-states) came from the correct message.

References can be **linear** for simple workflows or they can create **tree-like** structures for more complex ones.

This section guides you through some common messaging workflows that use both of these structures.

## Sending public payloads

The most basic messaging workflow for sending public payloads is linear, where all messages reference the `Announce` message.

![Announce workflow](../images/workflow.png)

In this workflow, subscribers read and verify the `Announce` message, then they add the information to their states, using the `unwrap_announcement()` method.

Subscribers can then use the information in their states to verify future `SignedPacket` messages that reference this `Announce` message.

## Generating a session key

The author has two choices of workflow to generate the session key for authorized subscribers.

### Accepting requests for read access

In this workflow, subscribers request read access to private payloads by using the information in the `Announce` message to create and publish a `Subscribe` message.

The author listens for these messages and adds the subscribers' public encryption keys to its state, using the `unwrap_subscribe()` method.

Using these keys, the author generates a session key for the authorized subscribers and publishes it in a `Keyload` message.

:::info:
This message should reference the `Announce` message because it contains the information that subscribers need to decrypt the session key.
:::

When subscribers process the `Keyload` message, the session key is added to their spongos states, using the `unwrap_keyload()` method.

The author can then publish private payloads in either `SignedPacket` or `TaggedPacket` messages and reference the `Keyload` message to tell subscribers where the correct session key is.

### Pre-selecting authorized subscribers 

In this workflow, the author decides which subscribers should be allowed access to private payloads before announcing the channel. These subscribers may come from an external source such as a list of members' email addresses in a database.

The author may choose this option to avoid the overhead of managing `Subscribe` messages.

To set up subscribers before announcing the channel, the author can choose them in advance and either establish a pre-shared key or request their NTRU keys.

The author can then later use these keys to create a `Keyload` message.

### Changing the signature keys

If the author runs out of signature keys, a new set can be generated by publishing a `ChangeKey` message. This way, the author can continue signing messages on the same channel.

:::info:
The author needs at least one key pair left in the Merkle tree to be able to sign the `ChangeKey` message and prove your ownership of the channel.
:::

The `ChangeKey` message should reference either an `Announce` message or a previous `ChangeKey` message so that subscribers can verify signatures using the author's current public key.

To verify future signatures using the author's latest public key, subscribers must use the `unwrap_change_key()` method to update their states.

## Unsubscribing from a channel

If subscribers no longer plan on reading encrypted messages on the channel, they can notify the author by publishing an `Unsubscribe` message.

By notifying the author of their intent to unsubscribe, subscribers reduce the amount of computation that the author must do to generate future session keys.

`Unsubscribe` messages must always reference the corresponding `Subscribe` message because it contains the information that the author needs to verify message.

To remove the subscribers' keys from future `Keyload` messages, the author must use the `unwrap_unsubscribe()` method to remove their keys from the state.

## Next steps

Once your messaging workflows are ready, you can build the logic that defines how these messages will be processed.

Try our guide for [building a simple app](../channels/build-a-simple-app.md) that uses the public message workflow.