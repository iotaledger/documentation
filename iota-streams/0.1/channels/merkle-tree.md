# Channel's Merkle tree

**This article explains how Merkle trees are used in the creation of channels.**

Channels uses Winternitz [one-time signatures](https://en.wikipedia.org/wiki/Hash-based_cryptography#One-time_signature_schemes) (W-OTS) to allow authors to prove ownership of a channel. This signature scheme is quantum robust, meaning that signatures are resistant to attacks by quantum computers. But, the scheme also reveals an unknown amount of the private key that's used to sign messages. As a result, it's safe to sign the same message with the same private key only once. Signing different messages with the same private key allows attackers to forge a signature in their own messages on the channel.

To make sure that each message in a channel has the same channel address, the address is derived from a [Merkle tree signature scheme (MSS)]((https://en.wikipedia.org/wiki/Merkle_signature_scheme)).

In Channels, the root of the Merkle tree is the channel address and the leaves are the public keys.

This Merkle tree is generated by hashing the author's pre-generated public keys.

![Example of a Merkle tree](../channels/images/merkle-tree-channel.png)

By generating a Merkle tree, the author can prove ownership of the channel by doing the following:

- Signing each channel message with a different private key that belongs to one of the public key leaves
- Sending enough of the Merkle tree in the signed message to allow subscribers to validate the signature

The number of public keys that are pre-generated depends on the height of the Merkle tree, which is chosen by the author.

## Deciding the height of the Merkle tree

The height of a Merkle tree affects how many leaves it has, and thus how many messages the author can sign. The total number of key pairs is 2<sup>height</sup>. These key pairs are part of the MSS and the author uses them in the [`Announce`, `ChangeKey` and `SignedPacket` messages](../channels/message-types.md) to prove ownership of the channel.

Before creating a new channel, it's important to decide how many messages you want to be able to sign before running out of private keys.

However, if you do run out of private keys, you can send a signed `ChangeKey` message, which generates a new Merkle tree that allows you to continue sending signed messages on the same channel. To send this message type, you must have at least one private key left to be able to sign the message.

```rust
let mut author = Author::new("AUTHORSECRET", 2, true);
```

Here, the first argument is the author's secret string, which is used by a pseudo-random number generator to generate a seed. The second argument indicates the height of the author's Merkle tree.

